:py:mod:`cdhtools.ValueFinder`
==============================

.. py:module:: cdhtools.ValueFinder


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   cdhtools.ValueFinder.ValueFinder




.. py:class:: ValueFinder(path: Optional[str] = None, df: Optional[Union[pandas.DataFrame, polars.DataFrame, pyarrow.Table]] = None, verbose: bool = True, **kwargs)

   Class to analyze Value Finder datasets.

   Relies heavily on polars for faster reading and transformations.
   See https://pola-rs.github.io/polars/py-polars/html/index.html

   Requires either df or a path to be supplied,
   If a path is supplied, the 'filename' argument is optional.
   If path is given and no filename is, it will look for the most recent.

   :param path: Path to the ValueFinder data files
   :type path: Optional[str]
   :param df: Override to supply a dataframe instead of a file.
              Supports pandas or polars dataframes or pyarrow tables
   :type df: Optional[DataFrame]
   :param verbose: Whether to print out information during importing
   :type verbose: bool

   :keyword filename: The name, or extended filepath, towards the file
   :kwtype filename: Optional[str]

   .. py:method:: getCustomerSummary(self, th: Optional[float] = None, verbose: bool = True) -> polars.DataFrame

      Computes the summary of propensities for all customers

      :param th: The threshold to consider an action 'good'.
                 If a customer has actions with propensity above this,
                 the customer has at least one relevant action.
                 If not given, will default to 5th quantile.
      :type th: Optional[float]
      :param verbose: Whether to print out the execution times
      :type verbose: bool, default = True


   .. py:method:: getCountsPerStage(self, customersummary: Optional[polars.DataFrame] = None, verbose: bool = True) -> polars.DataFrame

      Generates an aggregated view per stage.

      :param customersummary: Optional override of the customer summary,
                              which can be generated by getCustomerSummary().
      :type customersummary: Optional[pl.DataFrame]
      :param verbose: Whether to print execution times.
      :type verbose: bool, default = True


   .. py:method:: addCountsPerThresholdRange(self, start: float, stop: float, step: float, verbose: bool = True)

      Adds the counts per stage for a range of quantiles.

      In the background, uses numpy's arange function
      to generate the range of quantiles.
      Then, for each quantile the counts per stage are computed,
      and added to the 'countsPerThreshold' dictionary.
      As optimization, if a quantile produces a threshold that is
      already previously computed, it simply adds that computed dataframe.

      :param start: The starting quantile
      :type start: float
      :param stop: The ending quantile
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float
      :param verbose: Whether to print out the progress of computation
      :type verbose: bool, default = True


   .. py:method:: plotPropensityDistribution(self, sampledN: int = 10000) -> plotly.graph_objects.Figure

      Plots the distribution of the different propensities.

      For optimization reasons (storage for all points in a boxplot and
      time complexity for computing the distribution plot),
      we have to sample to a reasonable amount of data points.

      :param sampledN: The number of datapoints to sample
      :type sampledN: int, default = 10_000


   .. py:method:: plotPropensityThreshold(self, sampledN=10000) -> plotly.graph_objects.Figure

      Plots the propensity threshold vs the different propensities.

      :param sampledN: The number of datapoints to sample
      :type sampledN: int, default = 10_000


   .. py:method:: plotPieCharts(self, start: Optional[float] = None, stop: Optional[float] = None, step: Optional[float] = None, verbose: bool = True)

      Plots the pie chart, split per stage.

      If start, stop and step are supplied,
      it will generate a slider to set the threshold
      dynamically throughout the given range of quantiles.
      If any of the is None, it will simply use the default
      threshold based on the 5th quantile.

      :param start: The starting quantile
      :type start: float
      :param stop: The ending quantile
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float
      :param verbose: Whether to print out the progress of computation
      :type verbose: bool, default = True


   .. py:method:: plotDistributionPerThreshold(self, target: str = 'Quantile', **kwargs)

      Plots the distribution of customers per threshold, per stage.

      Based on the precomputed data in self.countsPerThreshold,
      this function will plot the distribution per stage.

      To add more data points between a given range,
      simply pass all three arguments to this function:
      start, stop and step. Alternatively, you may
      call the self.addCountsPerThresholdRange() function,
      with the start, stop and step arguments outside of this call.

      :param target: Determines which threshold to plot:
                     based on the quantiles or the raw propensities.
                     One of: {'Quantile', 'Propensity'}
      :type target: str, default = Quantile

      :keyword start: The starting quantile
      :kwtype start: float
      :keyword stop: The ending quantile
      :kwtype stop: float
      :keyword step: The steps to compute between start and stop
      :kwtype step: float
      :keyword verbose: Whether to print out the progress of computation
      :kwtype verbose: bool, default = True


   .. py:method:: plotFunnelChart(self, level: str = 'Action', query=None)

      Plots the funnel of actions or issues per stage.

      :param level: Which element to plot:
                    - If 'Actions', plots the distribution of actions.
                    - If 'Issues', plots the distribution of issues
      :type level: str, default = 'Actions'



