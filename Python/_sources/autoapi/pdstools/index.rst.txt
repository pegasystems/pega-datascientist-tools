:py:mod:`pdstools`
==================

.. py:module:: pdstools

.. autoapi-nested-parse::

   Python pdstools



Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   adm/index.rst
   app/index.rst
   ih/index.rst
   plots/index.rst
   utils/index.rst
   valuefinder/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pdstools.ADMDatamart
   pdstools.ADMTrees
   pdstools.MultiTrees
   pdstools.ValueFinder
   pdstools.Config
   pdstools.DataAnonymization



Functions
~~~~~~~~~

.. autoapisummary::

   pdstools.CDHSample
   pdstools.SampleTrees
   pdstools.SampleValueFinder



Attributes
~~~~~~~~~~

.. autoapisummary::

   pdstools.__version__
   pdstools.__healthcheck_file__


.. py:data:: __version__
   :value: '3.0.0'

   

.. py:class:: ADMDatamart(path: str = '.', import_strategy: Literal[eager, lazy] = 'eager', *, model_filename: Optional[str] = 'modelData', predictor_filename: Optional[str] = 'predictorData', model_df: Optional[pdstools.utils.types.any_frame] = None, predictor_df: Optional[pdstools.utils.types.any_frame] = None, query: Optional[Union[polars.Expr, str, Dict[str, list]]] = None, subset: bool = True, drop_cols: Optional[list] = None, include_cols: Optional[list] = None, context_keys: list = ['Channel', 'Direction', 'Issue', 'Group'], extract_keys: bool = False, predictorCategorization: polars.Expr = cdh_utils.defaultPredictorCategorization, plotting_engine: Union[str, Any] = 'plotly', verbose: bool = False, **reading_opts)

   Bases: :py:obj:`pdstools.plots.plot_base.Plots`

   Main class for importing, preprocessing and structuring Pega ADM Datamart.
   Gets all available data, properly names and merges into one main dataframe

   :param path: The path of the data files
   :type path: str, default = "."
   :param import_strategy: Whether to import the file fully to memory, or scan the file
                           When data fits into memory, 'eager' is typically more efficient
                           However, when data does not fit, the lazy methods typically allow
                           you to still use the data.
   :type import_strategy: Literal['eager', 'lazy'], default = 'eager'

   :keyword model_filename: The name, or extended filepath, towards the model file
   :kwtype model_filename: Optional[str]
   :keyword predictor_filename: The name, or extended filepath, towards the predictors file
   :kwtype predictor_filename: Optional[str]
   :keyword model_df: Optional override to supply a dataframe instead of a file
   :kwtype model_df: Union[pl.DataFrame, pl.LazyFrame, pd.DataFrame]
   :keyword predictor_df: Optional override to supply a dataframe instead of a file
   :kwtype predictor_df: Union[pl.DataFrame, pl.LazyFrame, pd.DataFrame]
   :keyword query: Please refer to :meth:`._apply_query`
   :kwtype query: Union[pl.Expr, str, Dict[str, list]], default = None
   :keyword plotting_engine: Please refer to :meth:`.get_engine`
   :kwtype plotting_engine: str, default = "plotly"
   :keyword subset: Whether to only keep a subset of columns for efficiency purposes
                    Refer to :meth:`_available_columns` for the default list of columns.
   :kwtype subset: bool, default = True
   :keyword drop_cols  Optional[list]: Columns to exclude from reading
   :keyword include_cols: Additionial columns to include when reading
   :kwtype include_cols: Optional[list]
   :keyword context_keys: Which columns to use as context keys
   :kwtype context_keys: list, default = ["Channel", "Direction", "Issue", "Group"]
   :keyword extract_keys: Extra keys, particularly pyTreatment, are hidden within the pyName column.
                          extract_keys can expand that cell to also show these values.
                          To extract these extra keys, set extract_keys to True.
   :kwtype extract_keys: bool, default = False
   :keyword predictorCategorization: A Polars expression to determine the 'category' of a predictor.
                                     If None, uses PredictorCategory that is already there.
                                     See: :meth:`pdstools.utils.cdh_utils.defaultPredictorCategorization`
   :kwtype predictorCategorization: pl.Expr, default = :meth:`cdh_utils.defaultPredictorCategorization`
   :keyword verbose: Whether to print out information during importing
   :kwtype verbose: bool, default = False
   :keyword \*\*reading_opts: Additional parameters used while reading.
                              Refer to :meth:`pdstools.utils.cdh_utils.import_file` for more info.

   .. attribute:: modelData

      If available, holds the preprocessed data about the models

      :type: pl.LazyFrame

   .. attribute:: predictorData

      If available, holds the preprocessed data about the predictor binning

      :type: pl.LazyFrame

   .. attribute:: combinedData

      If both modelData and predictorData are available,
      holds the merged data about the models and predictors

      :type: pl.LazyFrame

   .. attribute:: import_strategy

      See the `import_strategy` parameter

   .. attribute:: query

      See the `query` parameter

   .. attribute:: context_keys

      See the `context_keys` parameter

   .. attribute:: verbose

      See the `verbose` parameter

   .. rubric:: Examples

   >>> Data =  ADMDatamart(f"/CDHSample")
   >>> Data =  ADMDatamart(f"Data/Adaptive Models & Predictors Export",
               model_filename = "Data-Decision-ADM-ModelSnapshot_AdaptiveModelSnapshotRepo20201110T085543_GMT/data.json",
               predictor_filename = "Data-Decision-ADM-PredictorBinningSnapshot_PredictorBinningSnapshotRepo20201110T084825_GMT/data.json")
   >>> Data =  ADMDatamart(f"Data/files",
               model_filename = "ModelData.csv",
               predictor_filename = "PredictorData.csv")

   .. py:method:: get_engine(plotting_engine)
      :staticmethod:

      Which engine to use for creating the plots.

      By supplying a custom class here, you can re-use the pdstools functions
      but create visualisations to your own specifications, in any library.


   .. py:method:: import_data(path: Optional[str] = '.', *, model_filename: Optional[str] = 'modelData', predictor_filename: Optional[str] = 'predictorData', model_df: Optional[pdstools.utils.types.any_frame] = None, predictor_df: Optional[pdstools.utils.types.any_frame] = None, subset: bool = True, drop_cols: Optional[list] = None, include_cols: Optional[list] = None, extract_keys: bool = False, verbose: bool = False, **reading_opts) -> Tuple[Optional[polars.LazyFrame], Optional[polars.LazyFrame]]

      Method to import & format the relevant data.

      The method first imports the model data, and then the predictor data.
      If model_df or predictor_df is supplied, it will use those instead
      If any filters are included in the the `query` argument of the ADMDatmart,
      those will be applied to the modeldata, and the predictordata will be
      filtered such that it only contains the modelids leftover after filtering.
      After reading, some additional values (such as success rate) are
      automatically computed.
      Lastly, if there are missing columns from both datasets,
      this will be printed to the user if verbose is True.

      :param path: The path of the data files
                   Default = current path (',')
      :type path: str
      :param subset: Whether to only select the renamed columns,
                     set to False to keep all columns
      :type subset: bool, default = True
      :param model_df: Optional override to supply a dataframe instead of a file
      :type model_df: pd.DataFrame
      :param predictor_df: Optional override to supply a dataframe instead of a file
      :type predictor_df: pd.DataFrame

      :returns: The model data and predictor binning data as dataframes
      :rtype: (pl.DataFrame, pl.DataFrame)


   .. py:method:: _import_utils(name: Union[str, pdstools.utils.types.any_frame], path: Optional[str] = None, *, subset: bool = True, extract_keys: bool = False, drop_cols: Optional[list] = None, include_cols: Optional[list] = None, **reading_opts) -> Tuple[polars.LazyFrame, dict, dict]

      Handler function to interface to the cdh_utils methods

      :param name: One of {modelData, predictorData}
                   or a dataframe
      :type name: Union[str, pl.DataFrame]
      :param path: The path of the data file
      :type path: str, default = None

      :keyword subset: Whether to only select the renamed columns,
                       set to False to keep all columns
      :kwtype subset: bool, default = True
      :keyword drop_cols: Supply columns to drop from the dataframe
      :kwtype drop_cols: list
      :keyword include_cols: Supply columns to include with the dataframe
      :kwtype include_cols: list
      :keyword extract_keys: Treatments are typically hidden within the pyName column,
                             extract_keys can expand that cell to also show these values.
      :kwtype extract_keys: bool
      :keyword Additional keyword arguments:
      :keyword -----------------:
      :keyword See readDSExport in cdh_utils:

      :returns: The requested dataframe,
                The renamed columns
                The columns missing in both dataframes
      :rtype: (pl.LazyFrame, dict, dict)


   .. py:method:: _available_columns(df: polars.LazyFrame, include_cols: Optional[list] = None, drop_cols: Optional[list] = None) -> Tuple[set, set]

      Based on the default names for variables, rename available data to proper formatting

      :param df: Input dataframe
      :type df: pl.LazyFrame
      :param include_cols: Supply columns to include with the dataframe
      :type include_cols: list
      :param drop_cols: Supply columns to not import at all
      :type drop_cols: list

      :returns: The original dataframe, but renamed for the found columns &
                The original and updated names for all renamed columns &
                The variables that were not found in the table
      :rtype: (pl.LazyFrame, set, set)


   .. py:method:: _set_types(df: pdstools.utils.types.any_frame, *, timestamp_fmt: str = '%Y%m%dT%H%M%S.%f %Z', strict_conversion: bool = True) -> pdstools.utils.types.any_frame
      :staticmethod:

      A method to change columns to their proper type

      :param df: The input dataframe
      :type df: Union[pl.DataFrame, pl.LazyFrame]

      :keyword timestamp_fmt: The format of Date type columns
      :kwtype timestamp_fmt: str
      :keyword strict_conversion: Raises an error if timestamp conversion to given/default date format(timestamp_fmt) fails
                                  See 'https://strftime.org/' for timestamp formats
      :kwtype strict_conversion: bool

      :returns: The input dataframe, but the proper typing applied
      :rtype: Union[pl.DataFrame, pl.LazyFrame]


   .. py:method:: last(table='modelData', strategy: Literal[eager, lazy] = 'eager') -> pdstools.utils.types.any_frame

      Convenience function to get the last values for a table

      :param table: Which table to get the last values for
                    One of {modelData, predictorData, combinedData}
      :type table: str, default = modelData
      :param strategy: Whether to import the file fully to memory, or scan the file
                       When data fits into memory, 'eager' is typically more efficient
                       However, when data does not fit, the lazy methods typically allow
                       you to still use the data.
      :type strategy: Literal['eager', 'lazy'], default = 'eager'

      :returns: The last snapshot for each model
      :rtype: Union[pl.DataFrame, pl.LazyFrame]


   .. py:method:: _last(df: pdstools.utils.types.any_frame) -> pdstools.utils.types.any_frame
      :staticmethod:

      Method to retrieve only the last snapshot.


   .. py:method:: _last_timestamp(col: Literal[ResponseCount, Positives]) -> polars.Expr
      :staticmethod:

      Add a column to indicate the last timestamp a column has changed.

      :param col: The column to calculate the diff for
      :type col: Literal['ResponseCount', 'Positives']


   .. py:method:: _get_combined_data(last=True, strategy: Literal[eager, lazy] = 'eager') -> pdstools.utils.types.any_frame

      Combines the model data and predictor data into one dataframe.

      :param last: Whether to only use the last snapshot for each table
      :type last: bool, default=True
      :param strategy: Whether to import the file fully to memory, or scan the file
                       When data fits into memory, 'eager' is typically more efficient
                       However, when data does not fit, the lazy methods typically allow
                       you to still use the data.
      :type strategy: Literal['eager', 'lazy'], default = 'eager'

      :returns: The combined dataframe
      :rtype: Union[pl.DataFrame, pl.LazyFrame]


   .. py:method:: save_data(path: str = '.') -> Tuple[os.PathLike, os.PathLike]

      Cache modelData and predictorData to files.

      :param path: Where to place the files
      :type path: str

      :returns: The paths to the model and predictor data files
      :rtype: (os.PathLike, os.PathLike)


   .. py:method:: _apply_query(df: pdstools.utils.types.any_frame, query: Optional[Union[polars.Expr, str, Dict[str, list]]] = None) -> polars.LazyFrame

      Given an input pandas dataframe, it filters the dataframe based on input query

      :param df: The input dataframe
      :type df: Union[pl.DataFrame, pl.LazyFrame]
      :param query: If a Polars Expression, passes the expression into Polars' filter function
                    If a string, uses the default Pandas query function (works only in eager mode)
                    Else, a dict of lists where the key is column name in the dataframe
                    and the corresponding value is a list of values to keep in the dataframe
      :type query: Optional[Union[pl.Expr, str, Dict[str, list]]]

      :returns: Filtered Polars DataFrame
      :rtype: pl.DataFrame


   .. py:method:: extract_keys(df, col='Name')


   .. py:method:: discover_modelTypes(df: polars.LazyFrame, by='Configuration')


   .. py:method:: get_AGB_models(last: bool = False, by: str = 'Configuration', n_threads: int = 1, query: Optional[Union[polars.Expr, str, Dict[str, list]]] = None, verbose: bool = True, **kwargs) -> Dict

      Method to automatically extract AGB models.

      Recommended to subset using the querying functionality
      to cut down on execution time, because it checks for each
      model ID. If you only have AGB models remaining after the query,
      it will only return proper AGB models.

      :param last: Whether to only look at the last snapshot for each model
      :type last: bool, default = False
      :param by: Which column to determine unique models with
      :type by: str, default = 'Configuration'
      :param n_threads: The number of threads to use for extracting the models.
                        Since we use multithreading, setting this to a reasonable value
                        helps speed up the import.
      :type n_threads: int, default = 6
      :param query: Please refer to :meth:`._apply_query`
      :type query: Optional[Union[pl.Expr, str, Dict[str, list]]]
      :param verbose: Whether to print out information while importing
      :type verbose: bool, default = False


   .. py:method:: _create_sign_df(df: polars.LazyFrame, by: str = 'Name', *, what: str = 'ResponseCount', every: str = '1d', pivot: bool = True, mask: bool = True) -> polars.LazyFrame
      :staticmethod:

      Generates dataframe to show whether responses decreased/increased from day to day

      For a given dataframe where columns are dates and rows are model names(by parameter),
      subtracts each day's value from the previous day's value per model. Then masks the data.
      If increased (desired situtation), it will put 1 in the cell, if no change, it will
      put 0, and if decreased it will put -1. This dataframe then could be used in the heatmap

      :param df: This is typically pivoted ModelData
      :type df: pd.DataFrame
      :param by: Column to calculate the daily change for.
      :type by: str, default = Name

      :keyword what: Column that contains response counts
      :kwtype what: str, default = ResponseCount
      :keyword every: Interval of the change window
      :kwtype every: str, default = 1d
      :keyword pivot: Returns a pivotted table with signs as value if set to true
      :kwtype pivot: bool, default = True
      :keyword mask: Drops SnapshotTime and returns direction of change(sign).
      :kwtype mask: bool, default = True

      :returns: The dataframe with signs for increase or decrease in day to day
      :rtype: pd.LazyFrame


   .. py:method:: model_summary(by: str = 'ModelID', query: Optional[Union[polars.Expr, str, Dict[str, list]]] = None, **kwargs) -> polars.LazyFrame

      Convenience method to automatically generate a summary over models

      By default, it summarizes ResponseCount, Performance, SuccessRate & Positives by model ID.
      It also adds weighted means for Performance and SuccessRate,
      And adds the count of models without responses and the percentage.

      :param by: By what column to summarize the models
      :type by: str, default = ModelID
      :param query: Please refer to :meth:`._apply_query`
      :type query: Optional[Union[pl.Expr, str, Dict[str, list]]]

      :returns: Groupby dataframe over all models
      :rtype: pl.LazyFrame


   .. py:method:: pivot_df(df: polars.LazyFrame, by: Union[str, list] = 'Name', *, allow_collect: bool = True, top_n: int = 0) -> polars.DataFrame

      Simple function to extract pivoted information

      :param df: The input DataFrame.
      :type df: pl.LazyFrame
      :param by: The column(s) to pivot the DataFrame by.
                 If a list is provided, only the first element is used.
      :type by: Union[str, list], default = Name
      :param allow_collect: Whether to allow eager computation.
                            If set to False and the import strategy is "lazy", an error will be raised.
      :type allow_collect: bool, default = True
      :param top_n: The number of rows to include in the pivoted DataFrame.
                    If set to 0, all rows are included.
      :type top_n: int, optional (default=0)

      :returns: The pivoted DataFrame.
      :rtype: pl.DataFrame


   .. py:method:: response_gain_df(df: pdstools.utils.types.any_frame, by: str = 'Channel') -> pdstools.utils.types.any_frame
      :staticmethod:

      Simple function to extract the response gain per model


   .. py:method:: models_by_positives_df(df: polars.LazyFrame, by: str = 'Channel', allow_collect=True) -> polars.LazyFrame

      Compute statistics on the dataframe by grouping it by a given column `by`
      and computing the count of unique ModelIDs and cumulative percentage of unique
      models for with regard to the number of positive answers.

      :param df: The input DataFrame
      :type df: pl.LazyFrame
      :param by: The column name to group the DataFrame by, by default "Channel"
      :type by: str, default = Channel
      :param allow_collect: Whether to allow eager computation. If set to False and the import strategy is "lazy", an error will be raised.
      :type allow_collect: bool, default = True

      :returns: DataFrame with PositivesBin column and model count statistics
      :rtype: pl.LazyFrame


   .. py:method:: get_model_stats(last: bool = True) -> dict

      Returns a dictionary containing various statistics for the model data.

      :param last: Whether to compute statistics only on the last snapshot. Defaults to True.
      :type last: bool

      :returns: A dictionary containing the following keys:
                'models_n_snapshots': The number of distinct snapshot times in the data.
                'models_total': The total number of models in the data.
                'models_empty': The models with no responses.
                'models_nopositives': The models with responses but no positive responses.
                'models_isimmature': The models with less than 200 positive responses.
                'models_noperformance': The models with at least 200 positive responses but a performance of 50.
                'models_n_nonperforming': The total number of models that are not performing well.
                'models_missing_{key}': The number of models with missing values for each context key.
                'models_bottom_left': The models with a performance of 50 and a success rate of 0.
      :rtype: Dict


   .. py:method:: describe_models(**kwargs) -> NoReturn

      Convenience method to quickly summarize the models


   .. py:method:: generateHealthCheck(name: Optional[str] = None, output_location='.', working_dir='.', delete_temp_files=True, output_type='html', allow_collect=True)

      Manually generates a Health Check

      The recommended way to run the Health Check is through the Streamlit app,
      which you get to by running `pdstools run` in your terminal/command line.
      However, it's also possible to directly run the Health Check from the
      ADMDatamart class, providing a little bit more flexibility.

      Internally, this method uses :meth:`.save_data` to save the model and
      predictor files to disk, which Quarto then picks up to generate.

      By running this method directly, you have control over the exact
      filters you want to use. Simply use the top-level :attr:`.query`
      argument to filter the ADMDatamart class to the desired level.

      :param name: The name of the Health Check file
      :type name: Optional[str]
      :param output_location: The output location of the generated file
      :type output_location: str, default = '.'
      :param working_dir: The directory in which to create the health check
      :type working_dir: str, default = '.'
      :param delete_temp_files: Whether to delete the temporary files used  while generating the file
                                If false, these files stay in working_dir
      :type delete_temp_files: bool, default = True
      :param output_type: Which type of export to create. Currently, html is best supported.
      :type output_type: : str, default = 'html'
      :param allow_collect: An override for the `lazy` memory_strategy. If set to True, still allows
                            for collecting of data. Naturally, we need to collect the data in order
                            to cache it to disk for the health check, so if set to False
                            with a `lazy` memory_strategy, you won't be able to generate.
      :type allow_collect: bool, default = True

      :returns: The full path to the generated Health Check file.
      :rtype: str



.. py:class:: ADMTrees

   .. py:method:: getMultiTrees(file: polars.DataFrame, n_threads=1, verbose=True, **kwargs)
      :staticmethod:



.. py:class:: MultiTrees

   .. py:property:: first


   .. py:property:: last


   .. py:attribute:: trees
      :type: dict

      

   .. py:attribute:: model_name
      :type: str

      

   .. py:attribute:: context_keys
      :type: list

      

   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: __getitem__(index)


   .. py:method:: __len__()


   .. py:method:: __add__(other)


   .. py:method:: computeOverTime(predictorCategorization=None)


   .. py:method:: plotSplitsPerVariableType(predictorCategorization=None, **kwargs)



.. py:class:: ValueFinder(path: Optional[str] = None, df: Optional[Union[pandas.DataFrame, polars.DataFrame, polars.LazyFrame]] = None, verbose: bool = True, **kwargs)

   Class to analyze Value Finder datasets.

   Relies heavily on polars for faster reading and transformations.
   See https://pola-rs.github.io/polars/py-polars/html/index.html

   Requires either df or a path to be supplied,
   If a path is supplied, the 'filename' argument is optional.
   If path is given and no filename is, it will look for the most recent.

   :param path: Path to the ValueFinder data files
   :type path: Optional[str]
   :param df: Override to supply a dataframe instead of a file.
              Supports pandas or polars dataframes
   :type df: Optional[DataFrame]
   :param verbose: Whether to print out information during importing
   :type verbose: bool

   :keyword filename: The name, or extended filepath, towards the file
   :kwtype filename: Optional[str]
   :keyword subset: Whether to select only a subset of columns.
                    Will speed up analysis and reduce unused information
   :kwtype subset: bool

   .. py:method:: save_data(path: str = '.') -> os.PathLike

      Cache the ValueFinder dataset to a file

      :param path: Where to place the file
      :type path: str

      :returns: The paths to the file
      :rtype: PathLike


   .. py:method:: getCustomerSummary(th: Optional[float] = None, verbose: bool = True) -> polars.DataFrame

      Computes the summary of propensities for all customers

      :param th: The threshold to consider an action 'good'.
                 If a customer has actions with propensity above this,
                 the customer has at least one relevant action.
                 If not given, will default to 5th quantile.
      :type th: Optional[float]
      :param verbose: Whether to print out the execution times
      :type verbose: bool, default = True


   .. py:method:: getCountsPerStage(customersummary: Optional[polars.DataFrame] = None, verbose: bool = True) -> polars.DataFrame

      Generates an aggregated view per stage.

      :param customersummary: Optional override of the customer summary,
                              which can be generated by getCustomerSummary().
      :type customersummary: Optional[pl.DataFrame]
      :param verbose: Whether to print execution times.
      :type verbose: bool, default = True


   .. py:method:: addCountsPerThresholdRange(start: float, stop: float, step: float, verbose: bool = True)

      Adds the counts per stage for a range of quantiles.

      In the background, uses numpy's arange function
      to generate the range of quantiles.
      Then, for each quantile the counts per stage are computed,
      and added to the 'countsPerThreshold' dictionary.
      As optimization, if a quantile produces a threshold that is
      already previously computed, it simply adds that computed dataframe.

      :param start: The starting quantile
      :type start: float
      :param stop: The ending quantile
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float
      :param verbose: Whether to print out the progress of computation
      :type verbose: bool, default = True


   .. py:method:: plotPropensityDistribution(sampledN: int = 10000) -> plotly.graph_objects.Figure

      Plots the distribution of the different propensities.

      For optimization reasons (storage for all points in a boxplot and
      time complexity for computing the distribution plot),
      we have to sample to a reasonable amount of data points.

      :param sampledN: The number of datapoints to sample
      :type sampledN: int, default = 10_000


   .. py:method:: plotPropensityThreshold(sampledN=10000, stage='Eligibility') -> plotly.graph_objects.Figure

      Plots the propensity threshold vs the different propensities.

      :param sampledN: The number of datapoints to sample
      :type sampledN: int, default = 10_000


   .. py:method:: plotPieCharts(start: Optional[float] = None, stop: Optional[float] = None, step: Optional[float] = None, verbose: bool = True)

      Plots the pie chart, split per stage.

      If start, stop and step are supplied,
      it will generate a slider to set the threshold
      dynamically throughout the given range of quantiles.
      If any of the is None, it will simply use the default
      threshold based on the 5th quantile.

      :param start: The starting quantile
      :type start: float
      :param stop: The ending quantile
      :type stop: float
      :param step: The steps to compute between start and stop
      :type step: float
      :param verbose: Whether to print out the progress of computation
      :type verbose: bool, default = True


   .. py:method:: plotDistributionPerThreshold(target: str = 'Quantile', **kwargs)

      Plots the distribution of customers per threshold, per stage.

      Based on the precomputed data in self.countsPerThreshold,
      this function will plot the distribution per stage.

      To add more data points between a given range,
      simply pass all three arguments to this function:
      start, stop and step. Alternatively, you may
      call the self.addCountsPerThresholdRange() function,
      with the start, stop and step arguments outside of this call.

      :param target: Determines which threshold to plot:
                     based on the quantiles or the raw propensities.
                     One of: {'Quantile', 'Propensity'}
      :type target: str, default = Quantile

      :keyword start: The starting quantile
      :kwtype start: float
      :keyword stop: The ending quantile
      :kwtype stop: float
      :keyword step: The steps to compute between start and stop
      :kwtype step: float
      :keyword verbose: Whether to print out the progress of computation
      :kwtype verbose: bool, default = True


   .. py:method:: plotFunnelChart(level: str = 'Action', query=None)

      Plots the funnel of actions or issues per stage.

      :param level: Which element to plot:
                    - If 'Actions', plots the distribution of actions.
                    - If 'Issues', plots the distribution of issues
      :type level: str, default = 'Actions'



.. py:class:: Config(config_file: Optional[str] = None, hds_folder: pathlib.Path = '.', use_datamart: bool = False, datamart_folder: pathlib.Path = 'datamart', output_format: Literal[ndjson, parquet, arrow, csv] = 'ndjson', output_folder: pathlib.Path = 'output', mapping_file: str = 'mapping.map', mask_predictor_names: bool = True, mask_context_key_names: bool = True, mask_ih_names: bool = True, mask_outcome_name: bool = True, mask_predictor_values: bool = True, mask_context_key_values: bool = True, mask_ih_values: bool = True, mask_outcome_values: bool = True, context_key_label: str = 'Context_*', ih_label: str = 'IH_*', outcome_column: str = 'Decision_Outcome', positive_outcomes: list = ['Accepted', 'Clicked'], negative_outcomes: list = ['Rejected', 'Impression'], special_predictors: list = ['Decision_DecisionTime', 'Decision_OutcomeTime'])

   Configuration file for the data anonymizer.

   :param config_file: An optional path to a config file
   :type config_file: str = None
   :param hds_folder: The path to the hds files
   :type hds_folder: Path = "."
   :param use_datamart: Whether to use the datamart to infer predictor types
   :type use_datamart: bool = False
   :param datamart_folder: The folder of the datamart files
   :type datamart_folder: Path = "datamart"
   :param output_format: The output format to write the files in
   :type output_format: Literal["ndjson", "parquet", "arrow", "csv"] = "ndjson"
   :param output_folder: The location to write the files to
   :type output_folder: Path = "output"
   :param mapping_file: The name of the predictor mapping file
   :type mapping_file: str = "mapping.map"
   :param mask_predictor_names: Whether to mask the names of regular predictors
   :type mask_predictor_names: bool = True
   :param mask_context_key_names: Whether to mask the names of context key predictors
   :type mask_context_key_names: bool = True
   :param mask_ih_names: Whether to mask the name of Interaction History summary predictors
   :type mask_ih_names: bool = True
   :param mask_outcome_name: Whether to mask the name of the outcome column
   :type mask_outcome_name: bool = True
   :param mask_predictor_values: Whether to mask the values of regular predictors
   :type mask_predictor_values: bool = True
   :param mask_context_key_values: Whether to mask the values of context key predictors
   :type mask_context_key_values: bool = True
   :param mask_ih_values: Whether to mask the values of Interaction History summary predictors
   :type mask_ih_values: bool = True
   :param mask_outcome_values: Whether to mask the values of the outcomes to binary
   :type mask_outcome_values: bool = True
   :param context_key_label: The pattern of names for context key predictors
   :type context_key_label: str = "Context_*"
   :param ih_label: The pattern of names for Interaction History summary predictors
   :type ih_label: str = "IH_*"
   :param outcome_column: The name of the outcome column
   :type outcome_column: str = "Decision_Outcome"
   :param positive_outcomes: Which positive outcomes to map to True
   :type positive_outcomes: list = ["Accepted", "Clicked"]
   :param negative_outcomes: Which negative outcomes to map to False
   :type negative_outcomes: list = ["Rejected", "Impression"]
   :param special_predictors: A list of special predictors which are not touched
   :type special_predictors: list = ["Decision_DecisionTime", "Decision_OutcomeTime"]

   .. py:method:: load_from_config_file(config_file: pathlib.Path)

      Load the configurations from a file.

      :param config_file: The path to the configuration file
      :type config_file: Path


   .. py:method:: save_to_config_file(file_name: str = None)

      Save the configurations to a file.

      :param file_name: The name of the configuration file
      :type file_name: str


   .. py:method:: validate_paths()

      Validate the outcome folder exists.



.. py:class:: DataAnonymization(config: Optional[Config] = None, df: Optional[polars.LazyFrame] = None, datamart: Optional[pdstools.ADMDatamart] = None, **config_args)

   Anonymize a historical dataset.

   :param config: Override the default configurations with the Config class
   :param df: Manually supply a Polars lazyframe to anonymize
   :param datamart: Manually supply a Datamart file to infer predictor types

   :keyword \*\*config_args: See :Class:`.Config`

   .. rubric:: Example

   See https://pegasystems.github.io/pega-datascientist-tools/Python/articles/Example_Data_Anonymization.html

   .. py:method:: write_to_output(df: Optional[polars.DataFrame] = None, ext: Literal[ndjson, parquet, arrow, csv] = None)

      Write the processed dataframe to an output file.

      :param df: Dataframe to write.
                 If not provided, runs `self.process()`
      :type df: Optional[pl.DataFrame]
      :param ext: What extension to write the file to
      :type ext: Literal["ndjson", "parquet", "arrow", "csv"]


   .. py:method:: create_mapping_file()

      Create a file to write the column mapping


   .. py:method:: load_hds_files()

      Load the historical dataset files from the `config.hds_folder` location.


   .. py:method:: read_predictor_type_from_file(df: polars.LazyFrame)
      :staticmethod:

      Infer the types of the preditors from the data.

      This is non-trivial, as it's not ideal to pull in all data to memory for this.
      For this reason, we sample 1% of data, or all data if less than 50 rows,
      and try to cast it to numeric. If that fails, we set it to categorical,
      else we set it to numeric.

      It is technically supported to manually override this, by just overriding
      the `symbolic_predictors_to_mask` & `numeric_predictors_to_mask` properties.

      :param df: The lazyframe to infer the types with
      :type df: pl.LazyFrame


   .. py:method:: read_predictor_type_from_datamart(datamart_folder: pathlib.Path, datamart: pdstools.ADMDatamart = None)
      :staticmethod:

      The datamart contains type information about each predictor.
      This function extracts that information to infer types for the HDS.

      :param datamart_folder: The path to the datamart files
      :type datamart_folder: Path
      :param datamart: The direct ADMDatamart object
      :type datamart: ADMDatamart


   .. py:method:: get_columns_by_type()

      Get a list of columns for each type.


   .. py:method:: get_predictors_mapping()

      Map the predictor names to their anonymized form.


   .. py:method:: getHasher(cols, algorithm='xxhash', seed: Union[Literal[0, random], int] = 0, seed_1=None, seed_2=None, seed_3=None)


   .. py:method:: process(**kwargs)

      Anonymize the dataset.



.. py:function:: CDHSample(plotting_engine='plotly', query=None, **kwargs)


.. py:function:: SampleTrees()


.. py:function:: SampleValueFinder(verbose=True)


.. py:data:: __healthcheck_file__

   

